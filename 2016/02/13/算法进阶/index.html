<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>算法进阶 | 美漂的野指针</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法进阶</h1><a id="logo" href="/.">美漂的野指针</a><p class="description">Make a difference</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">算法进阶</h1><div class="post-meta">Feb 13, 2016<span> | </span><span class="category"><a href="/categories/Algorithm/">算法</a></span></div><div class="post-content"><h3 id="1-Sweep-Line-算法"><a href="#1-Sweep-Line-算法" class="headerlink" title="1. Sweep-Line 算法"></a>1. Sweep-Line 算法</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近发现了一种非常有意思的算法，叫做Sweep Line，但是该算法问题界定的范围不像DP, Greedy那么明确，所以暂称类Sweep Line问题吧。下面就通过实际问题来阐述。</p>
<h4 id="例子：最长递增子序列问题"><a href="#例子：最长递增子序列问题" class="headerlink" title="例子：最长递增子序列问题"></a>例子：最长递增子序列问题</h4><p>该问题的描述如下：<br>给定一个未排序的序列，找到其中最长的递增子序列，可以不连续。一般该问题可以用 DP 来解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || <span class="number">1</span> &gt; nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] opt = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(opt, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    opt[i] = Math.max(opt[i], opt[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, opt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 DP 算法的时间复杂度为<code>O(n^2)</code>。这是大部分算法学习者都可以达到的正常水平，但是在这之外，我无意中发现有人用开挂技能来KO这道题，这就是文章一开始说的 Sweep Line 算法，而该算法可以达到<code>O(nlog(n))</code>的时间复杂度。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>, j = size;</span><br><span class="line">       	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        	<span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">           	<span class="keyword">if</span> (result[m] &lt; x)</span><br><span class="line">            	i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	j = m;</span><br><span class="line">        &#125;</span><br><span class="line">       	result[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == size) ++size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法主要是维护了一个已经访问过的最长的递增序列，当新的数来临时，找到序列中第一个比该数大的数进行替换，如果都比该数小，则将该数放到递增子序列的末尾，递增子序列长度加一。所以外层遍历时间复杂度是<code>O(n)</code>,而由于递增子序列已经递增有序，所以找到第一个比该数大的数可以用二分查找，时间复杂度是 <code>O(log(n))</code>。</p>
<h3 id="2-Shuffling-Algorithm"><a href="#2-Shuffling-Algorithm" class="headerlink" title="2. Shuffling Algorithm"></a>2. Shuffling Algorithm</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>洗牌算法是一个比较经典的算法，主要讨论如何随机生成一副牌。第一次遇见是2013年春腾讯一面的时候，当时妥妥跪了，题目都没听懂，第二次遇见是大三上系统结构课，最后讲到了洗牌算法。比较经典详细的算法解释参见<span style="color: #3366ff;"><a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" rel="noopener">维基百科</a></span>。这里主要讨论一种流行的简化版本。</p>
<h4 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h4><p>主要思路是从扑克的最后一张开始，假设下标为 i，然后从在区间[0, i - 1]中生成随机数j，交换下标为i，j所对应的元素。如此从最后一张循环操作到第二张（到第一张时可以跳出循环）。</p>
<p>C++代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># define CARDNUM 52</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shuffling</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* shuffle()&#123;</span><br><span class="line">        <span class="keyword">int</span>* cards = <span class="keyword">new</span> <span class="keyword">int</span>[CARDNUM];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= <span class="number">13</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; <span class="number">4</span>; j ++)&#123;</span><br><span class="line">                cards[index ++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = CARDNUM - <span class="number">1</span>; i &amp;gt;= <span class="number">1</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand() % i;</span><br><span class="line">            swap(cards, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shuffling action = Shuffling();</span><br><span class="line">    <span class="keyword">int</span>* a = action.shuffle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; CARDNUM; i ++)&#123;</span><br><span class="line">        cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span> max)&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span>[] cards = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; max; i ++)&#123;</span><br><span class="line">            cards[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = max - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">int</span> exchange = rand.nextInt(i);</span><br><span class="line">            <span class="keyword">int</span> tmp = cards[i];</span><br><span class="line">            cards[i] = cards[exchange];</span><br><span class="line">            cards[exchange] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cards;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-TOP-K-问题"><a href="#3-TOP-K-问题" class="headerlink" title="3. TOP-K 问题"></a>3. TOP-K 问题</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>top k问题是指给定元素集合，找出前k大的元素，或者找出出现频率前k大的元素。这个问题在算法课上经常讨论，但是却从未实现过，现在就来实现一下改算法。</p>
<p>top k问题暴力求解方法当然是对所有元素的比较依据元素进行排序，然后选出前k大的元素，这里的时间复杂度是O(nlg(n))，空间复杂度是O(1)。但是这个效率不高，改进主要有两种方法，一种是利用堆，一种是利用快排的辅助函数quick search算法。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先，我们用第一种方法来实现一下，以找出文中出现频率最高的单词为例。首先，我们需要遍历文本，构造｛单词：频率｝的哈希表，这里的时间复杂度是O(1)，空间复杂度是O(n)。然后我们再遍历一遍哈希表，利用小顶堆找出出现频率钱k大的单词，该时间复杂度是O(nlog(k))，空间复杂度是O(k)（关于堆操作的时间空间复杂度在这就不再赘述了）。综上，利用堆来处理topK问题的时间复杂度是O(nlog(k))，空间复杂度是O(n)。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pengfeixing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] topKWords(String stream, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WordFrequency</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">WordFrequency</span>&gt;</span>&#123;</span><br><span class="line">            String word;</span><br><span class="line">            <span class="keyword">int</span> frequency;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">WordFrequency</span><span class="params">(String word, <span class="keyword">int</span> frequency)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.word = word;</span><br><span class="line">                <span class="keyword">this</span>.frequency = frequency;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(WordFrequency o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.frequency, o.frequency);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&amp;lt;String, Integer&amp;gt; mp = <span class="keyword">new</span> HashMap&amp;lt;String, Integer&amp;gt;();</span><br><span class="line">        PriorityQueue&amp;lt;WordFrequency&amp;gt; topKHeap = <span class="keyword">new</span> PriorityQueue&amp;lt;WordFrequency&amp;gt;(k);</span><br><span class="line"></span><br><span class="line">        String[] words = stream.toLowerCase().trim().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            <span class="keyword">int</span> wordFrequency = mp.containsKey(word) ? mp.get(word) + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            mp.put(word, wordFrequency);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&amp;lt;String, Integer&amp;gt; e : mp.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(topKHeap.size() &amp;lt; k)&#123;</span><br><span class="line">                topKHeap.add(<span class="keyword">new</span> WordFrequency(e.getKey(), e.getValue()));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getValue() &amp;gt; topKHeap.peek().frequency)&#123;</span><br><span class="line">                topKHeap.remove();</span><br><span class="line">                topKHeap.add(<span class="keyword">new</span> WordFrequency(e.getKey(), e.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] topK = <span class="keyword">new</span> String[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(topKHeap.size() &amp;gt; <span class="number">0</span>)&#123;</span><br><span class="line">            topK[index ++] = topKHeap.remove().word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，由于是topK，所有用小顶堆。如果是选取出现最少的，则用大顶堆，只需要将compareTo中的反回方法顺序调换一下。关于compareTo的返回值，有三个0，1，－1。</p>
<p>接下来，我们用快排算法中用到的quick search来解决top k问题。即找到第k大的出现频率，然后将所有单词的频率和该频率进行比较，大于该数值的则为输出结果。该算法的时间复杂度是O(n)，空间复杂度是O(k)。</p>
<p>实现如下：</p>
<p>＃我们假设有找出数组中第k大的数的函数，为findkthLargestNumber(int[] nums, int k);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKWords</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] topKWordsQuickSearch(String stream, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WordFrequency</span> <span class="keyword">implements</span> <span class="title">Comparable</span>(<span class="title">WordFrequency</span>)</span>&#123;</span><br><span class="line">            String word;</span><br><span class="line">            <span class="keyword">int</span> frequency;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">WordFrequency</span><span class="params">(String word, <span class="keyword">int</span> frequency)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.word = word;</span><br><span class="line">                <span class="keyword">this</span>.frequency = frequency;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(WordFrequency o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.frequency, o.frequency);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; mp = <span class="keyword">new</span> HashMap&amp;lt;String, Integer&amp;gt;();</span><br><span class="line">        PriorityQueue&amp;lt;WordFrequency&amp;gt; topKHeap = <span class="keyword">new</span> PriorityQueue&lt;WordFrequency&gt;(k);</span><br><span class="line"></span><br><span class="line">        String[] words = stream.toLowerCase().trim().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            <span class="keyword">int</span> wordFrequency = mp.containsKey(word) ? mp.get(word) + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            mp.put(word, wordFrequency);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[mp.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&amp;lt;String, Integer&amp;gt; e : mp)&#123;</span><br><span class="line">            frequency[index ++] = e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> kthFrequency = findkthLargestNumber(frequency, k);</span><br><span class="line"></span><br><span class="line">        String[] topK = <span class="keyword">new</span> String[k];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&amp;lt;String, Integer&amp;gt; e : mp.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.getValue() &amp;gt;= kthFrequency)&#123;</span><br><span class="line">                topK[index ++] = e.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-Trie"><a href="#4-Trie" class="headerlink" title="4. Trie"></a>4. Trie</h3><p>单词查找树是介绍详见<a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">维基百科</a>，主要解决的问题是在一个字符串集合中快速找出目标字符串。实现如下：</p>
<p>给定一个字符串数组，构建单词查找树。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        String word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span></span>&#123;</span><br><span class="line">        TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">            TrieNode p = root;</span><br><span class="line">            <span class="keyword">for</span>(Character c : w.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">int</span> index = c - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(p.next[index] == <span class="keyword">null</span>) p.next[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                p = p.next[index];</span><br><span class="line">            &#125;</span><br><span class="line">            p.word = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们的应用场景是给定一个N*M的字符串矩阵，一个单词列表，返回所有可以在字符串矩阵中存在的单词。该问题过于复杂，我们可以先来处理简化版本。</p>
<p>简化版本是，将单词列表换成一个单词，判断该字符串矩阵是否能找出该单词。比如，给定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="string">"ABCCED"</span>-&gt;TRUE</span><br><span class="line"><span class="string">"SEE"</span>-&gt;TRUE</span><br><span class="line"><span class="string">"ABCB"</span>-&gt;FALSE</span><br></pre></td></tr></table></figure></p>
<p>该问题可以用dfs递归解决，算法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> visited[][];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(board, visited, word, i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] visited, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &lt; board.length || j &lt; <span class="number">0</span> || j &gt; board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(index) != board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(board, visited, word, i - <span class="number">1</span>, j, index + <span class="number">1</span>) ||</span><br><span class="line">                         dfs(board, visited, word, i + <span class="number">1</span>, j, index + <span class="number">1</span>) ||</span><br><span class="line">                         dfs(board, visited, word, i, j - <span class="number">1</span>, index + <span class="number">1</span>) ||</span><br><span class="line">                         dfs(board, visited, word, i, j + <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，当要查找的目标变成一个字符串集合时，问题就会变复杂了，当然可以暴力遍历改集合，不断调用上面方法，但是时间复杂度很高。所有，这里就要借用单词查找树（Trie）。实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TrieNode root = buildTrie(words);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(board, i, j, root, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode p, List&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'#'</span> || p.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        p = p.next[c - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p.word != <span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(p.word);</span><br><span class="line">            p.word = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j, p, result);</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, p, result);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, p, result);</span><br><span class="line">        <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, p, result);</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-区间重叠问题"><a href="#5-区间重叠问题" class="headerlink" title="5. 区间重叠问题"></a>5. 区间重叠问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定n个区间，找出重叠数量最多所对应的点。形象化描述是有4个飞机的schedule:[1,2], [3,4], [2,5], [3,6]，空中最多有多少架飞机。这里答案是3，因为在时刻3和4，空中飞机的数量最多，为3。为了简单起见，有两个假设：</p>
<p>假设1: 区间起点和终点都是整数；</p>
<p>假设2:假设同一时刻有一个飞机降落，另外一架飞机起飞，则先降落后起飞。</p>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>首先想到的是greedy algorithm，进行三层遍历循环。先将所有区间按照起始数值排序，然后依次遍历区间数组，在每次遍历某个区间时，又遍历该区间的每个数值，将该数值和区间数组中的剩下的区间进行比较，看是否重合。该算法在OJ上能通过87%的case，但是当测试集变大之后就会超时。算法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> classs Interval &#123;</span><br><span class="line">     <span class="keyword">int</span> start, end;</span><br><span class="line">     Interval(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">         <span class="keyword">this</span>.start = start;</span><br><span class="line">         <span class="keyword">this</span>.end = end;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervals: An interval array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Count of airplanes are in the sky.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(airplanes.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sortList(airplanes);</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (airplanes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Interval head = airplanes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head.start; i &lt; head.end; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; airplanes.size(); j++)&#123;</span><br><span class="line">                    Interval time = airplanes.get(j);</span><br><span class="line">                    <span class="keyword">if</span> (time.start &lt;= i &amp;amp;&amp;amp; time.end &gt; i)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time.end &lt;= i)&#123;</span><br><span class="line">                        airplanes.remove(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxCount = Math.max(count, maxCount);</span><br><span class="line">            &#125;</span><br><span class="line">            airplanes.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort a Interval list by the start point(ascending order)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortList</span><span class="params">(List&lt;Interval&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i).start &gt; list.get(j).start)&#123;</span><br><span class="line">                    Interval tmp = list.get(i);</span><br><span class="line">                    list.set(i, list.get(j));</span><br><span class="line">                    list.set(j, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TEST CASE:</span></span><br><span class="line"><span class="comment">        [1,1]</span></span><br><span class="line"><span class="comment">        [1,2],[2,3]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>为了对算法进行进一步的优化，我们可以对问题进行类比，区间重叠问题可以类比为括号最大深度的问题，即求解“()((()))()”中最大的括号深度，答案是3。算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classs Interval &#123;</span><br><span class="line">     <span class="keyword">int</span> start, end;</span><br><span class="line">     Interval(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">         <span class="keyword">this</span>.start = start;</span><br><span class="line">         <span class="keyword">this</span>.end = end;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> isStart;</span><br><span class="line">    Pair(<span class="keyword">int</span> time, <span class="keyword">int</span> isStart) &#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">        <span class="keyword">this</span>.isStart = isStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&amp;lt;Pair&amp;gt; PairComparator = <span class="keyword">new</span> Comparator&amp;lt;Pair&amp;gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair p1, Pair p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.time == p2.time) <span class="keyword">return</span> p1.isStart - p2.isStart;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p1.time - p2.time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervals: An interval array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Count of airplanes are in the sky.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span></span>&#123;</span><br><span class="line">        List&lt;Pair&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span> * airplanes.size());</span><br><span class="line">        <span class="keyword">for</span> (Interval i : airplanes)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Pair(i.start, <span class="number">1</span>));</span><br><span class="line">            list.add(<span class="keyword">new</span> Pair(i.end, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, Pair.PairComparator);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Pair p : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.isStart == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TEST CASE:</span></span><br><span class="line"><span class="comment">        [1,1]</span></span><br><span class="line"><span class="comment">        [1,2],[2,3]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Java中没有类似C++中的Pair数据类型，所以我们在这边就手写了一个class，用来实现和Pair类似的功能。</p>
<h3 id="6-图的遍历分析"><a href="#6-图的遍历分析" class="headerlink" title="6. 图的遍历分析"></a>6. 图的遍历分析</h3><h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p>如果只是粗略地讲图的遍历，即DFS和BFS是完全不用讲这一个点，但是，本着讲（装）透（逼）的原则，还是要简要介绍一下图在计算机中的存储方式，因为在后面的时间复杂度分析中会用到。</p>
<p>图的存储基本有两种，邻接矩阵（Adjacency Matrix）和邻接表（Adjacency List）。首先来说邻接矩阵，顾名思义，邻接矩阵是一个n*n矩阵，其中n是指图中节点数目，横纵坐标对应相应的节点，对于普通图来说，如果某两个节点中有边相连，则将这两点在邻接矩阵中对应的元素赋值为1，反之则为0；对于加权图来说，如果某两点间有边相连，则将邻接矩阵中对应的元素赋值为该权值，反之则为＋Infinity。</p>
<p>邻接矩阵在处理密集图比较好，但是对于稀疏图来说就会存在空间利用率不足的弊端，这就要用到邻接表。邻接表是一种数组与链表相对结合的方式，数组中存放的是图中所有的节点（node），然后每个node又是一个链表的头节点，每个链表中的节点是图中所有与改链表头节点相邻的节点，如果是有向图，则是由头节点指向的节点。可见，邻接表的空间复杂度是和图中节点数和边数成正比的，不像邻接矩阵中的n*n是固定的，所以在处理稀疏图时首选邻接表。</p>
<p>总结一下，图的两种存储的空间复杂度分别为（图中有n个节点，m条边）：</p>
<p>邻接矩阵：O(n * n)</p>
<p>邻接表：O(m + n)</p>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>图的遍历分为深度优先（DFS）和广度优先（BFS）。首先来讲广度优先，广度优先是一层一层的遍历图，由于本篇重在分析，所以略过具体的过程描述，伪代码如下。</p>
<p><pre class="lang:default decode:true ">set start vertex to visited</pre></p>
<p>load it into queue</p>
<pre><code>while queue not empty

    for each edge incident to vertex

         if its not visited

             load into queue

             mark vertex&lt;/pre&gt;
</code></pre><p>现在我们来分析一下它的时间复杂度，简单起见，我们假设图是用邻接表存储的。假设用集合{v1, v2, v3, …, vn}来表示途中的n个节点，则执行时间可以简单描述为：</p>
<p>v1 + (从v1出去的边数) ＋ v2 ＋ (从v2出去的边数) ＋ v3 ＋ … ＋ vn ＋ (从vn出去的边数)</p>
<p>变换为：</p>
<p>(v1 + v2 + … + vn) + {(从v1出去的边数) + (从v2出去的边数) + … + (从vn出去的边数) }</p>
<p>前一部分是O(n)，后一部分是O(m)，所以，综上，用邻接表存储的图的BFS时间复杂度是O(m + n)。</p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>深度优先，深度优先就是一条路走到底，然后再走另外一条。同样略过具体实现细节，类比于BFS，DFS也是将所有点和边都走一边，只不过点边的访问顺序不一样，所以，时间复杂度同样为O(m + n)。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>这不同于上文所说的图的存储的空间复杂度，而是图在遍历过程中额外的空间开销。在图的遍历中，为了避免因为图中有环而对同一点重复访问造成死循环，所以引入一个矩阵，来标志某点是否已经被访问，该矩阵长度为n，所以DFS和BFS的空间复杂度就为O(n)。</p>
<h3 id="7-有向图单源最短路径算法"><a href="#7-有向图单源最短路径算法" class="headerlink" title="7. 有向图单源最短路径算法"></a>7. 有向图单源最短路径算法</h3><h4 id="有向图的实现"><a href="#有向图的实现" class="headerlink" title="有向图的实现"></a>有向图的实现</h4><p>首先，我们再来讨论一下图。图是数据结构中相当重要的一部分，与之相关的算法也有很多，但是如果要让你代码实现有向图，相信很多人都会写很长的时间。下面就用Java实现一个Adjacency List存储的有向图。关于图的存储，可以参见<a href="http://pengfeixing.com/2016/02/19/图遍历/">这篇博客</a>。</p>
<p>这里主要定义了三个类，点(Vertex)、边(Edge)、有向图（Digraph）。</p>
<h4 id="Vetex-Class"><a href="#Vetex-Class" class="headerlink" title="Vetex Class"></a>Vetex Class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GraphImplementation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by novelidea on 2/28/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistance</span><span class="params">(<span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">        distance = dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Edge-Class"><a href="#Edge-Class" class="headerlink" title="Edge Class"></a>Edge Class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GraphImplementation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by novelidea on 2/28/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vertex in;</span><br><span class="line">    <span class="keyword">private</span> Vertex out;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(Vertex i, Vertex o, <span class="keyword">int</span> w)&#123;</span><br><span class="line">        in = i;</span><br><span class="line">        out = o;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">getIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">getOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">getAdjacentVertex</span><span class="params">(Vertex v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.getId().equals(in.getId()) ? out : in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Directed-Graph-Class"><a href="#Directed-Graph-Class" class="headerlink" title="Directed Graph Class"></a>Directed Graph Class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GraphImplementation;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by novelidea on 2/28/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Vertex, ArrayList&lt;Edge&gt;&gt; adjacentList = <span class="keyword">new</span> HashMap&lt;Vertex, ArrayList&lt;Edge&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(Vertex v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(adjacentList.containsKey(v)) <span class="keyword">return</span>;</span><br><span class="line">        adjacentList.put(v, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Vertex in, Vertex out, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addVertex(in);</span><br><span class="line">        <span class="keyword">this</span>.addVertex(out);</span><br><span class="line">        adjacentList.get(in).add(<span class="keyword">new</span> Edge(in, out, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outDegree</span><span class="params">(Vertex v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjacentList.get(v).size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Vertex, ArrayList&lt;Edge&gt;&gt; getMap()&#123;</span><br><span class="line">        <span class="keyword">return</span> adjacentList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Edge&gt; <span class="title">getAdjacentEdges</span><span class="params">(Vertex v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjacentList.get(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dijkstra实现"><a href="#Dijkstra实现" class="headerlink" title="Dijkstra实现"></a>Dijkstra实现</h4><p>实现有向图单源最短路径主要是Dijkstra算法，下面为算法实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GraphImplementation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by novelidea on 2/28/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Digraph graph;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(Digraph g)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"the input graph cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.graph = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&amp;<span class="title">lt</span></span>;Vertex&amp;gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Vertex v1, Vertex v2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(v1.getDistance(), v2.getDistance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Vertex&gt; <span class="title">findShortestPath</span><span class="params">(String sourceID)</span></span>&#123;</span><br><span class="line">        Queue&lt;Vertex&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>, <span class="keyword">new</span> VertexComparator());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Vertex, ArrayList&lt;Edge&gt;&gt; e : graph.getMap().entrySet())&#123;</span><br><span class="line">            Vertex v = e.getKey();</span><br><span class="line">            <span class="keyword">if</span>(v.getId().equals(sourceID))&#123;</span><br><span class="line">                v.setDistance(<span class="number">0</span>);</span><br><span class="line">                queue.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Vertex&gt; visited = <span class="keyword">new</span> HashSet&lt;Vertex&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Vertex src = queue.poll();</span><br><span class="line">            visited.add(src);</span><br><span class="line">            <span class="keyword">for</span>(Edge e : graph.getAdjacentEdges(src))&#123;</span><br><span class="line">                Vertex v = e.getAdjacentVertex(src);</span><br><span class="line">                <span class="keyword">if</span>(! visited.contains(v))&#123;</span><br><span class="line">                    <span class="keyword">int</span> newDistance = src.getDistance() + e.getWeight();</span><br><span class="line">                    <span class="keyword">if</span>(newDistance &amp;lt; v.getDistance())&#123;</span><br><span class="line">                        v.setDistance(newDistance);</span><br><span class="line">                        visited.add(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph.getMap().keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/Algorithm/">Algorithm</a></div><div class="post-nav"><a class="pre" href="/2016/02/18/Java基础/">Java基础</a><a class="next" href="/2016/01/08/新浪微博Apple Watch客户端/">新浪微博Apple Watch客户端</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0MS8xMDE5Ng=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://pengfeixing.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">编程基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/">随笔</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Diary/" style="font-size: 15px;">Diary</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/写在岁末年初（2017）/">写在岁末年初 （2017）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/01/写在岁末年初（2016）/">写在岁末年初（2016）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/27/算法基础/">算法基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/07/IOS开发中的四大对象及程序启动过程混讲/">iOS开发中的四大对象及程序启动过程混讲</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/09/IOS沙盒简介/">iOS沙盒简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/18/Java基础/">Java基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/13/算法进阶/">算法进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/08/新浪微博Apple Watch客户端/">新浪微博Apple Watch客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/写在岁末年初（2015）/">写在岁末年初（2015）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/23/Uschedule项目日志/">Uschedule 项目日志</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">美漂的野指针.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + theme.baidu_analytics;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>